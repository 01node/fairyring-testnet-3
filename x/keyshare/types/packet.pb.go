// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fairyring/keyshare/packet.proto

package types

import (
	fmt "fmt"
	types "github.com/Fairblock/fairyring/x/common/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/durationpb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type KeysharePacketData struct {
	// Types that are valid to be assigned to Packet:
	//	*KeysharePacketData_NoData
	//	*KeysharePacketData_RequestAggrKeysharePacket
	//	*KeysharePacketData_GetAggrKeysharePacket
	//	*KeysharePacketData_AggrKeyshareDataPacket
	//	*KeysharePacketData_CurrentKeysPacket
	//	*KeysharePacketData_RequestPrivKeysharePacket
	//	*KeysharePacketData_GetPrivateKeysharePacket
	Packet isKeysharePacketData_Packet `protobuf_oneof:"packet"`
}

func (m *KeysharePacketData) Reset()         { *m = KeysharePacketData{} }
func (m *KeysharePacketData) String() string { return proto.CompactTextString(m) }
func (*KeysharePacketData) ProtoMessage()    {}
func (*KeysharePacketData) Descriptor() ([]byte, []int) {
	return fileDescriptor_220841e1bebf3b1b, []int{0}
}
func (m *KeysharePacketData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeysharePacketData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeysharePacketData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeysharePacketData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeysharePacketData.Merge(m, src)
}
func (m *KeysharePacketData) XXX_Size() int {
	return m.Size()
}
func (m *KeysharePacketData) XXX_DiscardUnknown() {
	xxx_messageInfo_KeysharePacketData.DiscardUnknown(m)
}

var xxx_messageInfo_KeysharePacketData proto.InternalMessageInfo

type isKeysharePacketData_Packet interface {
	isKeysharePacketData_Packet()
	MarshalTo([]byte) (int, error)
	Size() int
}

type KeysharePacketData_NoData struct {
	NoData *NoData `protobuf:"bytes,1,opt,name=noData,proto3,oneof" json:"noData,omitempty"`
}
type KeysharePacketData_RequestAggrKeysharePacket struct {
	RequestAggrKeysharePacket *RequestAggrKeysharePacketData `protobuf:"bytes,2,opt,name=requestAggrKeysharePacket,proto3,oneof" json:"requestAggrKeysharePacket,omitempty"`
}
type KeysharePacketData_GetAggrKeysharePacket struct {
	GetAggrKeysharePacket *GetAggrKeysharePacketData `protobuf:"bytes,3,opt,name=getAggrKeysharePacket,proto3,oneof" json:"getAggrKeysharePacket,omitempty"`
}
type KeysharePacketData_AggrKeyshareDataPacket struct {
	AggrKeyshareDataPacket *AggrKeyshareDataPacketData `protobuf:"bytes,4,opt,name=aggrKeyshareDataPacket,proto3,oneof" json:"aggrKeyshareDataPacket,omitempty"`
}
type KeysharePacketData_CurrentKeysPacket struct {
	CurrentKeysPacket *CurrentKeysPacketData `protobuf:"bytes,5,opt,name=currentKeysPacket,proto3,oneof" json:"currentKeysPacket,omitempty"`
}
type KeysharePacketData_RequestPrivKeysharePacket struct {
	RequestPrivKeysharePacket *RequestPrivateKeysharePacketData `protobuf:"bytes,6,opt,name=request_priv_keyshare_packet,json=requestPrivKeysharePacket,proto3,oneof" json:"request_priv_keyshare_packet,omitempty"`
}
type KeysharePacketData_GetPrivateKeysharePacket struct {
	GetPrivateKeysharePacket *GetPrivateKeysharePacketData `protobuf:"bytes,7,opt,name=getPrivateKeysharePacket,proto3,oneof" json:"getPrivateKeysharePacket,omitempty"`
}

func (*KeysharePacketData_NoData) isKeysharePacketData_Packet()                    {}
func (*KeysharePacketData_RequestAggrKeysharePacket) isKeysharePacketData_Packet() {}
func (*KeysharePacketData_GetAggrKeysharePacket) isKeysharePacketData_Packet()     {}
func (*KeysharePacketData_AggrKeyshareDataPacket) isKeysharePacketData_Packet()    {}
func (*KeysharePacketData_CurrentKeysPacket) isKeysharePacketData_Packet()         {}
func (*KeysharePacketData_RequestPrivKeysharePacket) isKeysharePacketData_Packet() {}
func (*KeysharePacketData_GetPrivateKeysharePacket) isKeysharePacketData_Packet()  {}

func (m *KeysharePacketData) GetPacket() isKeysharePacketData_Packet {
	if m != nil {
		return m.Packet
	}
	return nil
}

func (m *KeysharePacketData) GetNoData() *NoData {
	if x, ok := m.GetPacket().(*KeysharePacketData_NoData); ok {
		return x.NoData
	}
	return nil
}

func (m *KeysharePacketData) GetRequestAggrKeysharePacket() *RequestAggrKeysharePacketData {
	if x, ok := m.GetPacket().(*KeysharePacketData_RequestAggrKeysharePacket); ok {
		return x.RequestAggrKeysharePacket
	}
	return nil
}

func (m *KeysharePacketData) GetGetAggrKeysharePacket() *GetAggrKeysharePacketData {
	if x, ok := m.GetPacket().(*KeysharePacketData_GetAggrKeysharePacket); ok {
		return x.GetAggrKeysharePacket
	}
	return nil
}

func (m *KeysharePacketData) GetAggrKeyshareDataPacket() *AggrKeyshareDataPacketData {
	if x, ok := m.GetPacket().(*KeysharePacketData_AggrKeyshareDataPacket); ok {
		return x.AggrKeyshareDataPacket
	}
	return nil
}

func (m *KeysharePacketData) GetCurrentKeysPacket() *CurrentKeysPacketData {
	if x, ok := m.GetPacket().(*KeysharePacketData_CurrentKeysPacket); ok {
		return x.CurrentKeysPacket
	}
	return nil
}

func (m *KeysharePacketData) GetRequestPrivKeysharePacket() *RequestPrivateKeysharePacketData {
	if x, ok := m.GetPacket().(*KeysharePacketData_RequestPrivKeysharePacket); ok {
		return x.RequestPrivKeysharePacket
	}
	return nil
}

func (m *KeysharePacketData) GetGetPrivateKeysharePacket() *GetPrivateKeysharePacketData {
	if x, ok := m.GetPacket().(*KeysharePacketData_GetPrivateKeysharePacket); ok {
		return x.GetPrivateKeysharePacket
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*KeysharePacketData) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*KeysharePacketData_NoData)(nil),
		(*KeysharePacketData_RequestAggrKeysharePacket)(nil),
		(*KeysharePacketData_GetAggrKeysharePacket)(nil),
		(*KeysharePacketData_AggrKeyshareDataPacket)(nil),
		(*KeysharePacketData_CurrentKeysPacket)(nil),
		(*KeysharePacketData_RequestPrivKeysharePacket)(nil),
		(*KeysharePacketData_GetPrivateKeysharePacket)(nil),
	}
}

type NoData struct {
}

func (m *NoData) Reset()         { *m = NoData{} }
func (m *NoData) String() string { return proto.CompactTextString(m) }
func (*NoData) ProtoMessage()    {}
func (*NoData) Descriptor() ([]byte, []int) {
	return fileDescriptor_220841e1bebf3b1b, []int{1}
}
func (m *NoData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoData.Merge(m, src)
}
func (m *NoData) XXX_Size() int {
	return m.Size()
}
func (m *NoData) XXX_DiscardUnknown() {
	xxx_messageInfo_NoData.DiscardUnknown(m)
}

var xxx_messageInfo_NoData proto.InternalMessageInfo

// RequestAggrKeysharePacketData defines a struct for the packet payload
type RequestAggrKeysharePacketData struct {
	Requester string `protobuf:"bytes,1,opt,name=requester,proto3" json:"requester,omitempty"`
	// Types that are valid to be assigned to Id:
	//	*RequestAggrKeysharePacketData_ProposalId
	//	*RequestAggrKeysharePacketData_RequestId
	Id             isRequestAggrKeysharePacketData_Id `protobuf_oneof:"id"`
	EstimatedDelay *time.Duration                     `protobuf:"bytes,4,opt,name=estimated_delay,json=estimatedDelay,proto3,stdduration" json:"estimated_delay,omitempty"`
}

func (m *RequestAggrKeysharePacketData) Reset()         { *m = RequestAggrKeysharePacketData{} }
func (m *RequestAggrKeysharePacketData) String() string { return proto.CompactTextString(m) }
func (*RequestAggrKeysharePacketData) ProtoMessage()    {}
func (*RequestAggrKeysharePacketData) Descriptor() ([]byte, []int) {
	return fileDescriptor_220841e1bebf3b1b, []int{2}
}
func (m *RequestAggrKeysharePacketData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestAggrKeysharePacketData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestAggrKeysharePacketData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestAggrKeysharePacketData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestAggrKeysharePacketData.Merge(m, src)
}
func (m *RequestAggrKeysharePacketData) XXX_Size() int {
	return m.Size()
}
func (m *RequestAggrKeysharePacketData) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestAggrKeysharePacketData.DiscardUnknown(m)
}

var xxx_messageInfo_RequestAggrKeysharePacketData proto.InternalMessageInfo

type isRequestAggrKeysharePacketData_Id interface {
	isRequestAggrKeysharePacketData_Id()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RequestAggrKeysharePacketData_ProposalId struct {
	ProposalId string `protobuf:"bytes,2,opt,name=proposal_id,json=proposalId,proto3,oneof" json:"proposal_id,omitempty"`
}
type RequestAggrKeysharePacketData_RequestId struct {
	RequestId string `protobuf:"bytes,3,opt,name=request_id,json=requestId,proto3,oneof" json:"request_id,omitempty"`
}

func (*RequestAggrKeysharePacketData_ProposalId) isRequestAggrKeysharePacketData_Id() {}
func (*RequestAggrKeysharePacketData_RequestId) isRequestAggrKeysharePacketData_Id()  {}

func (m *RequestAggrKeysharePacketData) GetId() isRequestAggrKeysharePacketData_Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *RequestAggrKeysharePacketData) GetRequester() string {
	if m != nil {
		return m.Requester
	}
	return ""
}

func (m *RequestAggrKeysharePacketData) GetProposalId() string {
	if x, ok := m.GetId().(*RequestAggrKeysharePacketData_ProposalId); ok {
		return x.ProposalId
	}
	return ""
}

func (m *RequestAggrKeysharePacketData) GetRequestId() string {
	if x, ok := m.GetId().(*RequestAggrKeysharePacketData_RequestId); ok {
		return x.RequestId
	}
	return ""
}

func (m *RequestAggrKeysharePacketData) GetEstimatedDelay() *time.Duration {
	if m != nil {
		return m.EstimatedDelay
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RequestAggrKeysharePacketData) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RequestAggrKeysharePacketData_ProposalId)(nil),
		(*RequestAggrKeysharePacketData_RequestId)(nil),
	}
}

type RequestPrivateKeysharePacketData struct {
	Requester string `protobuf:"bytes,1,opt,name=requester,proto3" json:"requester,omitempty"`
	RequestId string `protobuf:"bytes,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
}

func (m *RequestPrivateKeysharePacketData) Reset()         { *m = RequestPrivateKeysharePacketData{} }
func (m *RequestPrivateKeysharePacketData) String() string { return proto.CompactTextString(m) }
func (*RequestPrivateKeysharePacketData) ProtoMessage()    {}
func (*RequestPrivateKeysharePacketData) Descriptor() ([]byte, []int) {
	return fileDescriptor_220841e1bebf3b1b, []int{3}
}
func (m *RequestPrivateKeysharePacketData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestPrivateKeysharePacketData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestPrivateKeysharePacketData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestPrivateKeysharePacketData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestPrivateKeysharePacketData.Merge(m, src)
}
func (m *RequestPrivateKeysharePacketData) XXX_Size() int {
	return m.Size()
}
func (m *RequestPrivateKeysharePacketData) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestPrivateKeysharePacketData.DiscardUnknown(m)
}

var xxx_messageInfo_RequestPrivateKeysharePacketData proto.InternalMessageInfo

func (m *RequestPrivateKeysharePacketData) GetRequester() string {
	if m != nil {
		return m.Requester
	}
	return ""
}

func (m *RequestPrivateKeysharePacketData) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

type RequestPrivateKeysharePacketAck struct {
	Identity string `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	Pubkey   string `protobuf:"bytes,2,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
}

func (m *RequestPrivateKeysharePacketAck) Reset()         { *m = RequestPrivateKeysharePacketAck{} }
func (m *RequestPrivateKeysharePacketAck) String() string { return proto.CompactTextString(m) }
func (*RequestPrivateKeysharePacketAck) ProtoMessage()    {}
func (*RequestPrivateKeysharePacketAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_220841e1bebf3b1b, []int{4}
}
func (m *RequestPrivateKeysharePacketAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestPrivateKeysharePacketAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestPrivateKeysharePacketAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestPrivateKeysharePacketAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestPrivateKeysharePacketAck.Merge(m, src)
}
func (m *RequestPrivateKeysharePacketAck) XXX_Size() int {
	return m.Size()
}
func (m *RequestPrivateKeysharePacketAck) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestPrivateKeysharePacketAck.DiscardUnknown(m)
}

var xxx_messageInfo_RequestPrivateKeysharePacketAck proto.InternalMessageInfo

func (m *RequestPrivateKeysharePacketAck) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *RequestPrivateKeysharePacketAck) GetPubkey() string {
	if m != nil {
		return m.Pubkey
	}
	return ""
}

// RequestAggrKeysharePacketAck defines a struct for the packet acknowledgment
type RequestAggrKeysharePacketAck struct {
	Identity string `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	Pubkey   string `protobuf:"bytes,2,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
}

func (m *RequestAggrKeysharePacketAck) Reset()         { *m = RequestAggrKeysharePacketAck{} }
func (m *RequestAggrKeysharePacketAck) String() string { return proto.CompactTextString(m) }
func (*RequestAggrKeysharePacketAck) ProtoMessage()    {}
func (*RequestAggrKeysharePacketAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_220841e1bebf3b1b, []int{5}
}
func (m *RequestAggrKeysharePacketAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestAggrKeysharePacketAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestAggrKeysharePacketAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestAggrKeysharePacketAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestAggrKeysharePacketAck.Merge(m, src)
}
func (m *RequestAggrKeysharePacketAck) XXX_Size() int {
	return m.Size()
}
func (m *RequestAggrKeysharePacketAck) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestAggrKeysharePacketAck.DiscardUnknown(m)
}

var xxx_messageInfo_RequestAggrKeysharePacketAck proto.InternalMessageInfo

func (m *RequestAggrKeysharePacketAck) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *RequestAggrKeysharePacketAck) GetPubkey() string {
	if m != nil {
		return m.Pubkey
	}
	return ""
}

// GetAggrKeysharePacketData defines a struct for the packet payload
type GetAggrKeysharePacketData struct {
	Identity string `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
}

func (m *GetAggrKeysharePacketData) Reset()         { *m = GetAggrKeysharePacketData{} }
func (m *GetAggrKeysharePacketData) String() string { return proto.CompactTextString(m) }
func (*GetAggrKeysharePacketData) ProtoMessage()    {}
func (*GetAggrKeysharePacketData) Descriptor() ([]byte, []int) {
	return fileDescriptor_220841e1bebf3b1b, []int{6}
}
func (m *GetAggrKeysharePacketData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAggrKeysharePacketData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAggrKeysharePacketData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAggrKeysharePacketData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAggrKeysharePacketData.Merge(m, src)
}
func (m *GetAggrKeysharePacketData) XXX_Size() int {
	return m.Size()
}
func (m *GetAggrKeysharePacketData) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAggrKeysharePacketData.DiscardUnknown(m)
}

var xxx_messageInfo_GetAggrKeysharePacketData proto.InternalMessageInfo

func (m *GetAggrKeysharePacketData) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

// GetAggrKeysharePacketAck defines a struct for the packet acknowledgment
type GetAggrKeysharePacketAck struct {
}

func (m *GetAggrKeysharePacketAck) Reset()         { *m = GetAggrKeysharePacketAck{} }
func (m *GetAggrKeysharePacketAck) String() string { return proto.CompactTextString(m) }
func (*GetAggrKeysharePacketAck) ProtoMessage()    {}
func (*GetAggrKeysharePacketAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_220841e1bebf3b1b, []int{7}
}
func (m *GetAggrKeysharePacketAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAggrKeysharePacketAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAggrKeysharePacketAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAggrKeysharePacketAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAggrKeysharePacketAck.Merge(m, src)
}
func (m *GetAggrKeysharePacketAck) XXX_Size() int {
	return m.Size()
}
func (m *GetAggrKeysharePacketAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAggrKeysharePacketAck.DiscardUnknown(m)
}

var xxx_messageInfo_GetAggrKeysharePacketAck proto.InternalMessageInfo

// GetPrivateKeysharePacketData defines a struct for the packet payload
type GetPrivateKeysharePacketData struct {
	Identity     string `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	Requester    string `protobuf:"bytes,2,opt,name=requester,proto3" json:"requester,omitempty"`
	Rsa_64Pubkey string `protobuf:"bytes,3,opt,name=rsa_64_pubkey,json=rsa64Pubkey,proto3" json:"rsa_64_pubkey,omitempty"`
}

func (m *GetPrivateKeysharePacketData) Reset()         { *m = GetPrivateKeysharePacketData{} }
func (m *GetPrivateKeysharePacketData) String() string { return proto.CompactTextString(m) }
func (*GetPrivateKeysharePacketData) ProtoMessage()    {}
func (*GetPrivateKeysharePacketData) Descriptor() ([]byte, []int) {
	return fileDescriptor_220841e1bebf3b1b, []int{8}
}
func (m *GetPrivateKeysharePacketData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPrivateKeysharePacketData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPrivateKeysharePacketData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPrivateKeysharePacketData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPrivateKeysharePacketData.Merge(m, src)
}
func (m *GetPrivateKeysharePacketData) XXX_Size() int {
	return m.Size()
}
func (m *GetPrivateKeysharePacketData) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPrivateKeysharePacketData.DiscardUnknown(m)
}

var xxx_messageInfo_GetPrivateKeysharePacketData proto.InternalMessageInfo

func (m *GetPrivateKeysharePacketData) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *GetPrivateKeysharePacketData) GetRequester() string {
	if m != nil {
		return m.Requester
	}
	return ""
}

func (m *GetPrivateKeysharePacketData) GetRsa_64Pubkey() string {
	if m != nil {
		return m.Rsa_64Pubkey
	}
	return ""
}

// GetPrivateKeysharePacketAck defines a struct for the packet acknowledgment
type GetPrivateKeysharePacketAck struct {
}

func (m *GetPrivateKeysharePacketAck) Reset()         { *m = GetPrivateKeysharePacketAck{} }
func (m *GetPrivateKeysharePacketAck) String() string { return proto.CompactTextString(m) }
func (*GetPrivateKeysharePacketAck) ProtoMessage()    {}
func (*GetPrivateKeysharePacketAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_220841e1bebf3b1b, []int{9}
}
func (m *GetPrivateKeysharePacketAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPrivateKeysharePacketAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPrivateKeysharePacketAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPrivateKeysharePacketAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPrivateKeysharePacketAck.Merge(m, src)
}
func (m *GetPrivateKeysharePacketAck) XXX_Size() int {
	return m.Size()
}
func (m *GetPrivateKeysharePacketAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPrivateKeysharePacketAck.DiscardUnknown(m)
}

var xxx_messageInfo_GetPrivateKeysharePacketAck proto.InternalMessageInfo

// AggrKeyshareDataPacketData defines a struct for the packet payload
type AggrKeyshareDataPacketData struct {
	Identity     string `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	Pubkey       string `protobuf:"bytes,2,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	AggrKeyshare string `protobuf:"bytes,3,opt,name=aggr_keyshare,json=aggrKeyshare,proto3" json:"aggr_keyshare,omitempty"`
	AggrHeight   string `protobuf:"bytes,4,opt,name=aggr_height,json=aggrHeight,proto3" json:"aggr_height,omitempty"`
	ProposalId   string `protobuf:"bytes,5,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	RequestId    string `protobuf:"bytes,6,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	Retries      uint64 `protobuf:"varint,7,opt,name=retries,proto3" json:"retries,omitempty"`
}

func (m *AggrKeyshareDataPacketData) Reset()         { *m = AggrKeyshareDataPacketData{} }
func (m *AggrKeyshareDataPacketData) String() string { return proto.CompactTextString(m) }
func (*AggrKeyshareDataPacketData) ProtoMessage()    {}
func (*AggrKeyshareDataPacketData) Descriptor() ([]byte, []int) {
	return fileDescriptor_220841e1bebf3b1b, []int{10}
}
func (m *AggrKeyshareDataPacketData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggrKeyshareDataPacketData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AggrKeyshareDataPacketData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AggrKeyshareDataPacketData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggrKeyshareDataPacketData.Merge(m, src)
}
func (m *AggrKeyshareDataPacketData) XXX_Size() int {
	return m.Size()
}
func (m *AggrKeyshareDataPacketData) XXX_DiscardUnknown() {
	xxx_messageInfo_AggrKeyshareDataPacketData.DiscardUnknown(m)
}

var xxx_messageInfo_AggrKeyshareDataPacketData proto.InternalMessageInfo

func (m *AggrKeyshareDataPacketData) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *AggrKeyshareDataPacketData) GetPubkey() string {
	if m != nil {
		return m.Pubkey
	}
	return ""
}

func (m *AggrKeyshareDataPacketData) GetAggrKeyshare() string {
	if m != nil {
		return m.AggrKeyshare
	}
	return ""
}

func (m *AggrKeyshareDataPacketData) GetAggrHeight() string {
	if m != nil {
		return m.AggrHeight
	}
	return ""
}

func (m *AggrKeyshareDataPacketData) GetProposalId() string {
	if m != nil {
		return m.ProposalId
	}
	return ""
}

func (m *AggrKeyshareDataPacketData) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *AggrKeyshareDataPacketData) GetRetries() uint64 {
	if m != nil {
		return m.Retries
	}
	return 0
}

// AggrKeyshareDataPacketAck defines a struct for the packet acknowledgment
type AggrKeyshareDataPacketAck struct {
}

func (m *AggrKeyshareDataPacketAck) Reset()         { *m = AggrKeyshareDataPacketAck{} }
func (m *AggrKeyshareDataPacketAck) String() string { return proto.CompactTextString(m) }
func (*AggrKeyshareDataPacketAck) ProtoMessage()    {}
func (*AggrKeyshareDataPacketAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_220841e1bebf3b1b, []int{11}
}
func (m *AggrKeyshareDataPacketAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggrKeyshareDataPacketAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AggrKeyshareDataPacketAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AggrKeyshareDataPacketAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggrKeyshareDataPacketAck.Merge(m, src)
}
func (m *AggrKeyshareDataPacketAck) XXX_Size() int {
	return m.Size()
}
func (m *AggrKeyshareDataPacketAck) XXX_DiscardUnknown() {
	xxx_messageInfo_AggrKeyshareDataPacketAck.DiscardUnknown(m)
}

var xxx_messageInfo_AggrKeyshareDataPacketAck proto.InternalMessageInfo

type EncryptedKeysharesPacketData struct {
	Identity           string                         `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	Pubkey             string                         `protobuf:"bytes,2,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	RequestId          string                         `protobuf:"bytes,3,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	EncryptedKeyshares map[string]*types.KeyshareList `protobuf:"bytes,4,rep,name=encrypted_keyshares,json=encryptedKeyshares,proto3" json:"encrypted_keyshares,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *EncryptedKeysharesPacketData) Reset()         { *m = EncryptedKeysharesPacketData{} }
func (m *EncryptedKeysharesPacketData) String() string { return proto.CompactTextString(m) }
func (*EncryptedKeysharesPacketData) ProtoMessage()    {}
func (*EncryptedKeysharesPacketData) Descriptor() ([]byte, []int) {
	return fileDescriptor_220841e1bebf3b1b, []int{12}
}
func (m *EncryptedKeysharesPacketData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptedKeysharesPacketData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptedKeysharesPacketData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptedKeysharesPacketData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptedKeysharesPacketData.Merge(m, src)
}
func (m *EncryptedKeysharesPacketData) XXX_Size() int {
	return m.Size()
}
func (m *EncryptedKeysharesPacketData) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptedKeysharesPacketData.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptedKeysharesPacketData proto.InternalMessageInfo

func (m *EncryptedKeysharesPacketData) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *EncryptedKeysharesPacketData) GetPubkey() string {
	if m != nil {
		return m.Pubkey
	}
	return ""
}

func (m *EncryptedKeysharesPacketData) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *EncryptedKeysharesPacketData) GetEncryptedKeyshares() map[string]*types.KeyshareList {
	if m != nil {
		return m.EncryptedKeyshares
	}
	return nil
}

type EncryptedKeysharesPacketAck struct {
}

func (m *EncryptedKeysharesPacketAck) Reset()         { *m = EncryptedKeysharesPacketAck{} }
func (m *EncryptedKeysharesPacketAck) String() string { return proto.CompactTextString(m) }
func (*EncryptedKeysharesPacketAck) ProtoMessage()    {}
func (*EncryptedKeysharesPacketAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_220841e1bebf3b1b, []int{13}
}
func (m *EncryptedKeysharesPacketAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptedKeysharesPacketAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptedKeysharesPacketAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptedKeysharesPacketAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptedKeysharesPacketAck.Merge(m, src)
}
func (m *EncryptedKeysharesPacketAck) XXX_Size() int {
	return m.Size()
}
func (m *EncryptedKeysharesPacketAck) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptedKeysharesPacketAck.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptedKeysharesPacketAck proto.InternalMessageInfo

// CurrentKeysPacketData defines a struct for the packet payload
type CurrentKeysPacketData struct {
}

func (m *CurrentKeysPacketData) Reset()         { *m = CurrentKeysPacketData{} }
func (m *CurrentKeysPacketData) String() string { return proto.CompactTextString(m) }
func (*CurrentKeysPacketData) ProtoMessage()    {}
func (*CurrentKeysPacketData) Descriptor() ([]byte, []int) {
	return fileDescriptor_220841e1bebf3b1b, []int{14}
}
func (m *CurrentKeysPacketData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CurrentKeysPacketData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CurrentKeysPacketData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CurrentKeysPacketData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrentKeysPacketData.Merge(m, src)
}
func (m *CurrentKeysPacketData) XXX_Size() int {
	return m.Size()
}
func (m *CurrentKeysPacketData) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrentKeysPacketData.DiscardUnknown(m)
}

var xxx_messageInfo_CurrentKeysPacketData proto.InternalMessageInfo

// CurrentKeysPacketAck defines a struct for the packet acknowledgment
type CurrentKeysPacketAck struct {
	ActiveKey *types.ActivePublicKey `protobuf:"bytes,1,opt,name=activeKey,proto3" json:"activeKey,omitempty"`
	QueuedKey *types.QueuedPublicKey `protobuf:"bytes,2,opt,name=queuedKey,proto3" json:"queuedKey,omitempty"`
}

func (m *CurrentKeysPacketAck) Reset()         { *m = CurrentKeysPacketAck{} }
func (m *CurrentKeysPacketAck) String() string { return proto.CompactTextString(m) }
func (*CurrentKeysPacketAck) ProtoMessage()    {}
func (*CurrentKeysPacketAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_220841e1bebf3b1b, []int{15}
}
func (m *CurrentKeysPacketAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CurrentKeysPacketAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CurrentKeysPacketAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CurrentKeysPacketAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrentKeysPacketAck.Merge(m, src)
}
func (m *CurrentKeysPacketAck) XXX_Size() int {
	return m.Size()
}
func (m *CurrentKeysPacketAck) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrentKeysPacketAck.DiscardUnknown(m)
}

var xxx_messageInfo_CurrentKeysPacketAck proto.InternalMessageInfo

func (m *CurrentKeysPacketAck) GetActiveKey() *types.ActivePublicKey {
	if m != nil {
		return m.ActiveKey
	}
	return nil
}

func (m *CurrentKeysPacketAck) GetQueuedKey() *types.QueuedPublicKey {
	if m != nil {
		return m.QueuedKey
	}
	return nil
}

func init() {
	proto.RegisterType((*KeysharePacketData)(nil), "fairyring.keyshare.KeysharePacketData")
	proto.RegisterType((*NoData)(nil), "fairyring.keyshare.NoData")
	proto.RegisterType((*RequestAggrKeysharePacketData)(nil), "fairyring.keyshare.RequestAggrKeysharePacketData")
	proto.RegisterType((*RequestPrivateKeysharePacketData)(nil), "fairyring.keyshare.RequestPrivateKeysharePacketData")
	proto.RegisterType((*RequestPrivateKeysharePacketAck)(nil), "fairyring.keyshare.RequestPrivateKeysharePacketAck")
	proto.RegisterType((*RequestAggrKeysharePacketAck)(nil), "fairyring.keyshare.RequestAggrKeysharePacketAck")
	proto.RegisterType((*GetAggrKeysharePacketData)(nil), "fairyring.keyshare.GetAggrKeysharePacketData")
	proto.RegisterType((*GetAggrKeysharePacketAck)(nil), "fairyring.keyshare.GetAggrKeysharePacketAck")
	proto.RegisterType((*GetPrivateKeysharePacketData)(nil), "fairyring.keyshare.GetPrivateKeysharePacketData")
	proto.RegisterType((*GetPrivateKeysharePacketAck)(nil), "fairyring.keyshare.GetPrivateKeysharePacketAck")
	proto.RegisterType((*AggrKeyshareDataPacketData)(nil), "fairyring.keyshare.AggrKeyshareDataPacketData")
	proto.RegisterType((*AggrKeyshareDataPacketAck)(nil), "fairyring.keyshare.AggrKeyshareDataPacketAck")
	proto.RegisterType((*EncryptedKeysharesPacketData)(nil), "fairyring.keyshare.EncryptedKeysharesPacketData")
	proto.RegisterMapType((map[string]*types.KeyshareList)(nil), "fairyring.keyshare.EncryptedKeysharesPacketData.EncryptedKeysharesEntry")
	proto.RegisterType((*EncryptedKeysharesPacketAck)(nil), "fairyring.keyshare.EncryptedKeysharesPacketAck")
	proto.RegisterType((*CurrentKeysPacketData)(nil), "fairyring.keyshare.CurrentKeysPacketData")
	proto.RegisterType((*CurrentKeysPacketAck)(nil), "fairyring.keyshare.CurrentKeysPacketAck")
}

func init() { proto.RegisterFile("fairyring/keyshare/packet.proto", fileDescriptor_220841e1bebf3b1b) }

var fileDescriptor_220841e1bebf3b1b = []byte{
	// 863 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xcd, 0x8e, 0xe3, 0x44,
	0x10, 0x8e, 0x33, 0x99, 0xec, 0xa4, 0xc2, 0xf2, 0xd3, 0xec, 0x8f, 0x27, 0x9b, 0x71, 0x66, 0xbd,
	0x97, 0xe5, 0x80, 0x0d, 0x4b, 0xb4, 0x20, 0x2e, 0x28, 0xc3, 0x2c, 0x64, 0xb4, 0x08, 0x05, 0x4b,
	0x1c, 0xe0, 0x62, 0x75, 0xec, 0x5e, 0xa7, 0x95, 0x8c, 0xed, 0x69, 0xb7, 0x03, 0x96, 0x78, 0x08,
	0x8e, 0xfb, 0x48, 0x1c, 0x17, 0x71, 0xe1, 0x80, 0x04, 0x9a, 0x79, 0x01, 0x1e, 0x01, 0x75, 0xbb,
	0x9d, 0x5f, 0xdb, 0x2b, 0x2d, 0xb7, 0x76, 0xf7, 0x57, 0xdf, 0x57, 0x55, 0x5d, 0x55, 0x6e, 0x18,
	0xbc, 0xc0, 0x94, 0x65, 0x8c, 0x86, 0x81, 0x3d, 0x27, 0x59, 0x32, 0xc3, 0x8c, 0xd8, 0x31, 0xf6,
	0xe6, 0x84, 0x5b, 0x31, 0x8b, 0x78, 0x84, 0xd0, 0x0a, 0x60, 0x15, 0x80, 0x9e, 0x11, 0x44, 0x51,
	0xb0, 0x20, 0xb6, 0x44, 0x4c, 0xd3, 0x17, 0xb6, 0x9f, 0x32, 0xcc, 0x69, 0x14, 0xe6, 0x36, 0xbd,
	0x3b, 0x41, 0x14, 0x44, 0x72, 0x69, 0x8b, 0x95, 0xda, 0x7d, 0xb4, 0x96, 0xf2, 0xa2, 0xcb, 0xcb,
	0x28, 0xb4, 0x25, 0x9b, 0xef, 0xf2, 0x2c, 0x26, 0x49, 0x0e, 0x32, 0xff, 0x3a, 0x04, 0xf4, 0x5c,
	0xe9, 0x4c, 0xa4, 0x1f, 0xe7, 0x98, 0x63, 0x34, 0x84, 0x76, 0x18, 0x89, 0x95, 0xae, 0x9d, 0x6a,
	0x8f, 0xbb, 0x4f, 0x7a, 0xd6, 0xbe, 0x5b, 0xd6, 0xb7, 0x12, 0x31, 0x6e, 0x38, 0x0a, 0x8b, 0xae,
	0xe0, 0x98, 0x91, 0xab, 0x94, 0x24, 0x7c, 0x14, 0x04, 0x6c, 0x9b, 0x56, 0x6f, 0x4a, 0xa2, 0x8f,
	0xcb, 0x88, 0x9c, 0x2a, 0x23, 0xc5, 0x5f, 0xcd, 0x8a, 0x08, 0xdc, 0x0d, 0x48, 0x99, 0xdc, 0x81,
	0x94, 0xfb, 0xb0, 0x4c, 0xee, 0x6b, 0x52, 0x2d, 0x55, 0xce, 0x86, 0x66, 0x70, 0x0f, 0x6f, 0xec,
	0x0a, 0xb0, 0xd2, 0x69, 0x49, 0x1d, 0xab, 0x4c, 0x67, 0x54, 0x6a, 0xa1, 0x84, 0x2a, 0xf8, 0xd0,
	0x0f, 0xf0, 0x9e, 0x97, 0x32, 0x46, 0x42, 0x2e, 0x0e, 0x95, 0xc8, 0xa1, 0x14, 0xf9, 0xa0, 0x4c,
	0xe4, 0xcb, 0x5d, 0xb0, 0xe2, 0xdf, 0x67, 0x41, 0x3f, 0x41, 0x5f, 0x25, 0xd2, 0x8d, 0x19, 0x5d,
	0xba, 0x05, 0x87, 0x9b, 0x17, 0xa0, 0xde, 0x96, 0x2a, 0xc3, 0x9a, 0x1b, 0x9a, 0x30, 0xba, 0xc4,
	0x9c, 0xd4, 0x5e, 0x92, 0xc0, 0xec, 0x64, 0x2f, 0x04, 0x3d, 0x20, 0xe5, 0xc6, 0xfa, 0x2d, 0x29,
	0xfa, 0x51, 0xc5, 0x3d, 0xd5, 0x09, 0x56, 0x72, 0x9e, 0x1d, 0x41, 0x3b, 0x0f, 0xc9, 0x3c, 0x82,
	0x76, 0x5e, 0xa5, 0xe6, 0xef, 0x1a, 0x9c, 0xd4, 0xd6, 0x19, 0xea, 0x43, 0x47, 0x85, 0x40, 0x98,
	0x2c, 0xfb, 0x8e, 0xb3, 0xde, 0x40, 0x0f, 0xa1, 0x1b, 0xb3, 0x28, 0x8e, 0x12, 0xbc, 0x70, 0xa9,
	0x2f, 0xab, 0xb9, 0x33, 0x6e, 0x38, 0x50, 0x6c, 0x5e, 0xf8, 0x68, 0x00, 0x50, 0xe4, 0x97, 0xfa,
	0xb2, 0x00, 0x05, 0xa2, 0xe0, 0xb8, 0xf0, 0xd1, 0x18, 0xde, 0x21, 0x09, 0xa7, 0x97, 0x98, 0x13,
	0xdf, 0xf5, 0xc9, 0x02, 0x67, 0xaa, 0x7c, 0x8e, 0xad, 0xbc, 0xc3, 0xad, 0xa2, 0xc3, 0xad, 0x73,
	0xd5, 0xe1, 0x67, 0xad, 0x97, 0x7f, 0x0f, 0x34, 0xe7, 0xed, 0x95, 0xdd, 0xb9, 0x30, 0x3b, 0x6b,
	0x41, 0x93, 0xfa, 0xa6, 0x0b, 0xa7, 0xaf, 0xbb, 0x98, 0xd7, 0x44, 0x75, 0xb2, 0xe5, 0x72, 0x73,
	0xeb, 0xf8, 0xc2, 0x37, 0xbf, 0x87, 0x41, 0x9d, 0xc0, 0xc8, 0x9b, 0xa3, 0x1e, 0x1c, 0x51, 0x9f,
	0x84, 0x9c, 0xf2, 0x4c, 0xd1, 0xaf, 0xbe, 0xd1, 0x3d, 0x68, 0xc7, 0xe9, 0x74, 0x4e, 0x32, 0xc5,
	0xac, 0xbe, 0x4c, 0x07, 0xfa, 0x95, 0x57, 0xf1, 0xa6, 0x9c, 0x9f, 0xc2, 0x71, 0x65, 0x5f, 0xd7,
	0x11, 0x9a, 0x3d, 0xd0, 0x4b, 0x0d, 0x47, 0xde, 0xdc, 0xfc, 0x05, 0xfa, 0x75, 0x45, 0x58, 0xeb,
	0xe8, 0x56, 0xe2, 0x9b, 0xbb, 0x89, 0x37, 0xe1, 0x36, 0x4b, 0xb0, 0xfb, 0x74, 0xe8, 0xaa, 0x68,
	0x64, 0xb9, 0x38, 0x5d, 0x96, 0xe0, 0xa7, 0xc3, 0x49, 0x1e, 0xd2, 0x09, 0x3c, 0xa8, 0x52, 0x17,
	0xce, 0xfd, 0xab, 0x41, 0xaf, 0x7a, 0xc4, 0xbc, 0x49, 0x12, 0xd1, 0x23, 0xb8, 0x2d, 0xc6, 0xd2,
	0x6a, 0x32, 0x28, 0xaf, 0xde, 0xda, 0x9c, 0x55, 0x68, 0x00, 0x5d, 0x09, 0x9a, 0x11, 0x1a, 0xcc,
	0xf2, 0x01, 0xd8, 0x71, 0x40, 0x6c, 0x8d, 0xe5, 0x8e, 0x00, 0x6c, 0xb6, 0xca, 0x61, 0x0e, 0xd8,
	0x68, 0x94, 0xed, 0xaa, 0x6b, 0xef, 0x54, 0x1d, 0xd2, 0xe1, 0x16, 0x23, 0x9c, 0x51, 0x92, 0xc8,
	0xe9, 0xd0, 0x72, 0x8a, 0x4f, 0xf3, 0x01, 0x1c, 0x97, 0x47, 0x2c, 0xf2, 0xf1, 0x47, 0x13, 0xfa,
	0xcf, 0x42, 0x8f, 0x65, 0x31, 0x27, 0x7e, 0x01, 0x49, 0xfe, 0x67, 0x46, 0x4e, 0xf6, 0x7b, 0x7a,
	0xd3, 0xd5, 0x0c, 0xde, 0x27, 0x85, 0xe4, 0x2a, 0x6b, 0x89, 0xde, 0x3a, 0x3d, 0x78, 0xdc, 0x7d,
	0x32, 0x2e, 0x1b, 0x6a, 0x75, 0x1e, 0x96, 0x1c, 0x3e, 0x0b, 0x39, 0xcb, 0x1c, 0x44, 0xf6, 0x0e,
	0x7a, 0x04, 0xee, 0x57, 0xc0, 0xd1, 0xbb, 0x70, 0x20, 0x22, 0xc9, 0x63, 0x14, 0x4b, 0x34, 0x84,
	0xc3, 0x25, 0x5e, 0xa4, 0x44, 0xfd, 0x85, 0x8d, 0x0d, 0xcf, 0xf2, 0xb7, 0x81, 0x55, 0x50, 0x7c,
	0x43, 0x13, 0xee, 0xe4, 0xe0, 0xcf, 0x9b, 0x9f, 0x69, 0xa2, 0x08, 0xab, 0x5c, 0x16, 0x49, 0xbf,
	0x0f, 0x77, 0x4b, 0xff, 0x40, 0xe6, 0x4b, 0x0d, 0xee, 0xec, 0x9d, 0x88, 0xe6, 0xfe, 0x02, 0x3a,
	0xd8, 0xe3, 0x74, 0x29, 0x2a, 0x5a, 0xbd, 0x2e, 0x1e, 0xee, 0xbb, 0x33, 0x92, 0x90, 0x49, 0x3a,
	0x5d, 0x50, 0xef, 0x39, 0xc9, 0x9c, 0xb5, 0x8d, 0x20, 0xb8, 0x4a, 0x49, 0x2a, 0xdd, 0x51, 0xf1,
	0x94, 0x10, 0x7c, 0x27, 0x21, 0x1b, 0x04, 0x2b, 0x9b, 0xb3, 0x8b, 0xdf, 0xae, 0x0d, 0xed, 0xd5,
	0xb5, 0xa1, 0xfd, 0x73, 0x6d, 0x68, 0xbf, 0xde, 0x18, 0x8d, 0x57, 0x37, 0x46, 0xe3, 0xcf, 0x1b,
	0xa3, 0xf1, 0xa3, 0x1d, 0x50, 0x3e, 0x4b, 0xa7, 0x82, 0xc3, 0xfe, 0x0a, 0x53, 0x36, 0x5d, 0x44,
	0xde, 0xdc, 0x5e, 0xbf, 0xa3, 0x7e, 0x5e, 0x3f, 0xda, 0xe4, 0x23, 0x6a, 0xda, 0x96, 0x03, 0xfb,
	0x93, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xd1, 0x34, 0x15, 0xde, 0xd7, 0x09, 0x00, 0x00,
}

func (m *KeysharePacketData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeysharePacketData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeysharePacketData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Packet != nil {
		{
			size := m.Packet.Size()
			i -= size
			if _, err := m.Packet.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *KeysharePacketData_NoData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeysharePacketData_NoData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoData != nil {
		{
			size, err := m.NoData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *KeysharePacketData_RequestAggrKeysharePacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeysharePacketData_RequestAggrKeysharePacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestAggrKeysharePacket != nil {
		{
			size, err := m.RequestAggrKeysharePacket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *KeysharePacketData_GetAggrKeysharePacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeysharePacketData_GetAggrKeysharePacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GetAggrKeysharePacket != nil {
		{
			size, err := m.GetAggrKeysharePacket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *KeysharePacketData_AggrKeyshareDataPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeysharePacketData_AggrKeyshareDataPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AggrKeyshareDataPacket != nil {
		{
			size, err := m.AggrKeyshareDataPacket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *KeysharePacketData_CurrentKeysPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeysharePacketData_CurrentKeysPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CurrentKeysPacket != nil {
		{
			size, err := m.CurrentKeysPacket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *KeysharePacketData_RequestPrivKeysharePacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeysharePacketData_RequestPrivKeysharePacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestPrivKeysharePacket != nil {
		{
			size, err := m.RequestPrivKeysharePacket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *KeysharePacketData_GetPrivateKeysharePacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeysharePacketData_GetPrivateKeysharePacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GetPrivateKeysharePacket != nil {
		{
			size, err := m.GetPrivateKeysharePacket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *NoData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RequestAggrKeysharePacketData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestAggrKeysharePacketData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestAggrKeysharePacketData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EstimatedDelay != nil {
		n8, err8 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.EstimatedDelay, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.EstimatedDelay):])
		if err8 != nil {
			return 0, err8
		}
		i -= n8
		i = encodeVarintPacket(dAtA, i, uint64(n8))
		i--
		dAtA[i] = 0x22
	}
	if m.Id != nil {
		{
			size := m.Id.Size()
			i -= size
			if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestAggrKeysharePacketData_ProposalId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestAggrKeysharePacketData_ProposalId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ProposalId)
	copy(dAtA[i:], m.ProposalId)
	i = encodeVarintPacket(dAtA, i, uint64(len(m.ProposalId)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *RequestAggrKeysharePacketData_RequestId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestAggrKeysharePacketData_RequestId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.RequestId)
	copy(dAtA[i:], m.RequestId)
	i = encodeVarintPacket(dAtA, i, uint64(len(m.RequestId)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *RequestPrivateKeysharePacketData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestPrivateKeysharePacketData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestPrivateKeysharePacketData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestPrivateKeysharePacketAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestPrivateKeysharePacketAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestPrivateKeysharePacketAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pubkey) > 0 {
		i -= len(m.Pubkey)
		copy(dAtA[i:], m.Pubkey)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Pubkey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestAggrKeysharePacketAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestAggrKeysharePacketAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestAggrKeysharePacketAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pubkey) > 0 {
		i -= len(m.Pubkey)
		copy(dAtA[i:], m.Pubkey)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Pubkey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAggrKeysharePacketData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAggrKeysharePacketData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAggrKeysharePacketData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAggrKeysharePacketAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAggrKeysharePacketAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAggrKeysharePacketAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetPrivateKeysharePacketData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPrivateKeysharePacketData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPrivateKeysharePacketData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rsa_64Pubkey) > 0 {
		i -= len(m.Rsa_64Pubkey)
		copy(dAtA[i:], m.Rsa_64Pubkey)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Rsa_64Pubkey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetPrivateKeysharePacketAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPrivateKeysharePacketAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPrivateKeysharePacketAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AggrKeyshareDataPacketData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggrKeyshareDataPacketData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggrKeyshareDataPacketData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Retries != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Retries))
		i--
		dAtA[i] = 0x38
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProposalId) > 0 {
		i -= len(m.ProposalId)
		copy(dAtA[i:], m.ProposalId)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.ProposalId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AggrHeight) > 0 {
		i -= len(m.AggrHeight)
		copy(dAtA[i:], m.AggrHeight)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.AggrHeight)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AggrKeyshare) > 0 {
		i -= len(m.AggrKeyshare)
		copy(dAtA[i:], m.AggrKeyshare)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.AggrKeyshare)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Pubkey) > 0 {
		i -= len(m.Pubkey)
		copy(dAtA[i:], m.Pubkey)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Pubkey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AggrKeyshareDataPacketAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggrKeyshareDataPacketAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggrKeyshareDataPacketAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *EncryptedKeysharesPacketData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptedKeysharesPacketData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptedKeysharesPacketData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedKeyshares) > 0 {
		for k := range m.EncryptedKeyshares {
			v := m.EncryptedKeyshares[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPacket(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPacket(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPacket(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Pubkey) > 0 {
		i -= len(m.Pubkey)
		copy(dAtA[i:], m.Pubkey)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Pubkey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptedKeysharesPacketAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptedKeysharesPacketAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptedKeysharesPacketAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CurrentKeysPacketData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CurrentKeysPacketData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CurrentKeysPacketData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CurrentKeysPacketAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CurrentKeysPacketAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CurrentKeysPacketAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QueuedKey != nil {
		{
			size, err := m.QueuedKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ActiveKey != nil {
		{
			size, err := m.ActiveKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPacket(dAtA []byte, offset int, v uint64) int {
	offset -= sovPacket(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *KeysharePacketData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Packet != nil {
		n += m.Packet.Size()
	}
	return n
}

func (m *KeysharePacketData_NoData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoData != nil {
		l = m.NoData.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *KeysharePacketData_RequestAggrKeysharePacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestAggrKeysharePacket != nil {
		l = m.RequestAggrKeysharePacket.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *KeysharePacketData_GetAggrKeysharePacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetAggrKeysharePacket != nil {
		l = m.GetAggrKeysharePacket.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *KeysharePacketData_AggrKeyshareDataPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggrKeyshareDataPacket != nil {
		l = m.AggrKeyshareDataPacket.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *KeysharePacketData_CurrentKeysPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurrentKeysPacket != nil {
		l = m.CurrentKeysPacket.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *KeysharePacketData_RequestPrivKeysharePacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestPrivKeysharePacket != nil {
		l = m.RequestPrivKeysharePacket.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *KeysharePacketData_GetPrivateKeysharePacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetPrivateKeysharePacket != nil {
		l = m.GetPrivateKeysharePacket.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *NoData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RequestAggrKeysharePacketData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.Id != nil {
		n += m.Id.Size()
	}
	if m.EstimatedDelay != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.EstimatedDelay)
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *RequestAggrKeysharePacketData_ProposalId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProposalId)
	n += 1 + l + sovPacket(uint64(l))
	return n
}
func (m *RequestAggrKeysharePacketData_RequestId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestId)
	n += 1 + l + sovPacket(uint64(l))
	return n
}
func (m *RequestPrivateKeysharePacketData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *RequestPrivateKeysharePacketAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.Pubkey)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *RequestAggrKeysharePacketAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.Pubkey)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *GetAggrKeysharePacketData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *GetAggrKeysharePacketAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetPrivateKeysharePacketData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.Rsa_64Pubkey)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *GetPrivateKeysharePacketAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AggrKeyshareDataPacketData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.Pubkey)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.AggrKeyshare)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.AggrHeight)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.ProposalId)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.Retries != 0 {
		n += 1 + sovPacket(uint64(m.Retries))
	}
	return n
}

func (m *AggrKeyshareDataPacketAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *EncryptedKeysharesPacketData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.Pubkey)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	if len(m.EncryptedKeyshares) > 0 {
		for k, v := range m.EncryptedKeyshares {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPacket(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPacket(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPacket(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EncryptedKeysharesPacketAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CurrentKeysPacketData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CurrentKeysPacketAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActiveKey != nil {
		l = m.ActiveKey.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.QueuedKey != nil {
		l = m.QueuedKey.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func sovPacket(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPacket(x uint64) (n int) {
	return sovPacket(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *KeysharePacketData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeysharePacketData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeysharePacketData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NoData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Packet = &KeysharePacketData_NoData{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestAggrKeysharePacket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RequestAggrKeysharePacketData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Packet = &KeysharePacketData_RequestAggrKeysharePacket{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetAggrKeysharePacket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetAggrKeysharePacketData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Packet = &KeysharePacketData_GetAggrKeysharePacket{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggrKeyshareDataPacket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AggrKeyshareDataPacketData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Packet = &KeysharePacketData_AggrKeyshareDataPacket{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentKeysPacket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CurrentKeysPacketData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Packet = &KeysharePacketData_CurrentKeysPacket{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPrivKeysharePacket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RequestPrivateKeysharePacketData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Packet = &KeysharePacketData_RequestPrivKeysharePacket{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetPrivateKeysharePacket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetPrivateKeysharePacketData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Packet = &KeysharePacketData_GetPrivateKeysharePacket{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestAggrKeysharePacketData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestAggrKeysharePacketData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestAggrKeysharePacketData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = &RequestAggrKeysharePacketData_ProposalId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = &RequestAggrKeysharePacketData_RequestId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedDelay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EstimatedDelay == nil {
				m.EstimatedDelay = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.EstimatedDelay, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestPrivateKeysharePacketData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestPrivateKeysharePacketData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestPrivateKeysharePacketData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestPrivateKeysharePacketAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestPrivateKeysharePacketAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestPrivateKeysharePacketAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubkey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pubkey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestAggrKeysharePacketAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestAggrKeysharePacketAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestAggrKeysharePacketAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubkey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pubkey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAggrKeysharePacketData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAggrKeysharePacketData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAggrKeysharePacketData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAggrKeysharePacketAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAggrKeysharePacketAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAggrKeysharePacketAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPrivateKeysharePacketData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPrivateKeysharePacketData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPrivateKeysharePacketData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rsa_64Pubkey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rsa_64Pubkey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPrivateKeysharePacketAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPrivateKeysharePacketAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPrivateKeysharePacketAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggrKeyshareDataPacketData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggrKeyshareDataPacketData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggrKeyshareDataPacketData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubkey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pubkey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggrKeyshare", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggrKeyshare = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggrHeight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggrHeight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProposalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
			}
			m.Retries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retries |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggrKeyshareDataPacketAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggrKeyshareDataPacketAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggrKeyshareDataPacketAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptedKeysharesPacketData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptedKeysharesPacketData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptedKeysharesPacketData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubkey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pubkey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedKeyshares", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncryptedKeyshares == nil {
				m.EncryptedKeyshares = make(map[string]*types.KeyshareList)
			}
			var mapkey string
			var mapvalue *types.KeyshareList
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPacket
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPacket
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPacket
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPacket
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &types.KeyshareList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPacket(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPacket
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EncryptedKeyshares[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptedKeysharesPacketAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptedKeysharesPacketAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptedKeysharesPacketAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CurrentKeysPacketData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CurrentKeysPacketData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CurrentKeysPacketData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CurrentKeysPacketAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CurrentKeysPacketAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CurrentKeysPacketAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActiveKey == nil {
				m.ActiveKey = &types.ActivePublicKey{}
			}
			if err := m.ActiveKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueuedKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueuedKey == nil {
				m.QueuedKey = &types.QueuedPublicKey{}
			}
			if err := m.QueuedKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPacket(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPacket
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPacket
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPacket
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPacket        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPacket          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPacket = fmt.Errorf("proto: unexpected end of group")
)
